How to improve speed

using c++ for processing to avoid middleware .net compile

есть требования, что сравнение должно производиться по разным цветовым схемам, 
поэтому конвертация в серые это как кажется отсутпление от требований задачи. 
Вполне возможна реализация, что сравение пикселей по дефолту содержит схему, что
сначала конвертируем изображение в серый и сравниваем и это дефолтное по причине оптимизации

Общий подход - человекоразличимые различия(что подразумевает различия в цвете, поэтому подход с серым не оптимален)

ТАкже необходимо игнорировать смещения объектов

1) разбиваем изображение на квадраты, размер которых варьируется в зависимости от порога.
Данный подход добавляет оптимизацию в случае расширения приложения до "распараллеливания" вычислений
а также позволяет обрабатывать неограниченные размеры изображений.
Однако проигрывает в случае маленьких изображений. 
Если % отличающихся пикселей выше (в зависимости от порога) - считаем квадрат отличающимся
Дополнительные фильтры должны запускаться после "квадрат отличается"
Фильтры проверяют смещение во все стороны - включая диагональ. Если они выявляют, что квадрат
не отличается после применения фильтра - отличия игнорируется

Также необходимо подсчитывать отличия и прерывать выполнение, если порог достигнут
++ Если квадрат признан отличающимся - он обводится

Импрув - картинки обычно смещены целиком - посему по идее надо кешировать "направление" смещения для оптимизации
Также можно оптимизировать изменяя размер квадратов. сначала разбить пополам - сравнить. если есть отличия- 
разбить область пополам и сравнить части - так локализуются объекты отличий. 
данный подход содержит 2 важных момента
- можно использовать hash функцию для сравнения, однако она должна быть кастомной и учитыывать порог "отличия",т.е.
пиксель отличающийся меньше порога должен иметь идентичное значение hash в обоих изображениях
- необходимо учесть ситуацию, что кроме разбития "пополам" область локализации в исследуемом прямоугольнике
будет смещаться. То есть придется не просто делить область пополам, а сдвигать левый и правый край(верх и низ) при
делении области